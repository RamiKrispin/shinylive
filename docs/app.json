[{"name": "app.py", "content": "# Dependencies\nfrom shiny import App, render, ui\nfrom numpy import random \nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Functions\ndef random_steps(steps = 16, type = \"float\", low = -1, high = 1):\n    if type == \"int\":\n        r = random.randint(low = low, high=high, size= steps, dtype=int).tolist()\n        r = [high if i == 0 else i for i in r]\n    elif type == \"float\":\n        r = (high - low) * random.random_sample(size = steps) + low\n    else:\n        print(\"The type argument is not valid\")\n        return\n    return r\n\ndef cumsum(l):\n    c = []\n    t = 0\n    for i in range(0, len(l)):\n        t += l[i]\n        c.append(t)\n    return(c)\n\ndef sim_steps(sim_number = 10, steps = 16, type = \"float\"):\n    s = []\n    d = pd.DataFrame()\n    for i in range(0, sim_number):\n        v1 = [0]\n        v2 = random_steps(steps = steps, type = type)\n        if not isinstance(v2, list):\n            v2 = v2.tolist()\n        v = cumsum(v1 + v2)\n        d_temp = pd.DataFrame({\"sim\": i, \"step\": range(0, len(v)), \"y\": v})\n        d = pd.concat([d, d_temp])\n    return d\n\n\n# UI\napp_ui = ui.page_fluid(\n        ui.layout_sidebar(\n            ui.panel_sidebar(\n                ui.h2(\"Why normal distributions are normal\"),\n                ui.input_slider(\"sample_size\", \"Sample Size\", 1, 1000, 500),\n                ui.input_slider(\"steps\", \"Number of Steps\", 1, 20, 16),\n                ui.input_select(\"step\", \"Step Type\", {\"float\": \"Float\", \"int\": \"Integer\"}),\n                ui.input_slider(\"alpha\", \"Color Opacity\", 0, 1, 0.2)\n            ),\n        ui.panel_main(\n            ui.output_plot(\"plot\"),\n            ui.markdown(\n        \"\"\"\n        ### Why normal distributions are normal\n\n        Chapter 3 of [Statistical Rethinking's](https://xcelab.net/rm/statistical-rethinking/) by Prof. Richard McElreath focuses on normal distribution\n        and its characteristics. It illustrates how to generate a normal distribution using the soccer field experiment:\n\n        - Place a bunch of people at the center line of a soccer field\n        - Each person flips a coin and moves one step to the right or left according to the outcome (head or tail)\n        - Repeat this process multiple times\n        After a couple of iterations, you will notice the distribution of the people's distances across the field will become Gaussian or normal (e.g., bell-curved shape).\n\n        The app above simulates this experience by setting the sample size (i.e., number of people) and number of iterations. Where on each iteration, we draw a random number between -1 and 1 (can choose between float integer steps with the `Step Type` drop-down). The plot above shows the cumulative sum of each experiment across each step of the experience. You can notice how the distribution becomes more Gaussian as the number of steps increases.\n\n        Code available [here](https://github.com/RamiKrispin/shinyelive).\n\n        \"\"\"\n    ),\n        )\n    )\n)\n\n# Server\ndef server(input, output, session):\n    @output\n    @render.plot(alt=\"A simulation plot\")\n    def plot():\n        type = input.step()\n        color = \"lightblue\"\n        alpha = input.alpha()\n        sim_number = input.sample_size()\n        steps = input.steps()\n        sim_df = sim_steps(sim_number = sim_number, steps = steps, type = type)\n        fig, ax = plt.subplots()\n        for i in sim_df.sim.unique():\n            df = sim_df[sim_df[\"sim\"] == i]\n            ax.plot(df[\"step\"], df[\"y\"], color = color, alpha= alpha)\n\n        ax.set_title(label = \"Simulation of Random Walk\")\n        ax.set_xlabel(\"Number of Steps\")\n        ax.set_ylabel(\"Position\")\n        return fig\n\n\napp = App(app_ui, server)\n", "type": "text"}]